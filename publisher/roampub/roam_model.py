""" Model of the elements that appear in PageDump generated JSON files -- the output of ``PageDump.js``
 
Types:

    Uid
    VertexMap

Enums:

    VertexType
    MediaType

Classes:

    RoamVertex
    RoamNode
    PageNode
    BlockHeadingNode
    BlockContentNode
    FileVertex

Functions:

    validate(VertexMap) -> Optional[list[str]]

"""

from typing import TypeAlias, Any, Optional, Callable, Final, NamedTuple, cast
from abc import ABC, abstractmethod
from enum import StrEnum
from collections import OrderedDict
from functools import reduce
import logging

from common.types import Url
from common.introspect import get_property_values

Uid: TypeAlias = str
"""
Type for the values that pair with the key "uid" in PageDump.json.
    - if the Vertex corresponds 1-1 with a Roam Node (VertexType.is_roam_node == True), then uid is the Roam
        generated uid value 
    - if the Vertex is not 1-1 with a Roam Node (VertexType.is_roam_node == False), it was injected by PageDump.js and
        uid is a GUID generated by PageDump.js
"""

class VertexType(StrEnum):
    ROAM_PAGE = 'roam/page', True
    ROAM_BLOCK_CONTENT = 'roam/block-content', True
    ROAM_BLOCK_HEADING = 'roam/block-heading', True
    ROAM_FILE = 'roam/file', False
   
    def __new__(cls: Any, value: str, is_roam_node: bool):
        obj = str.__new__(cls)
        obj._value_ = value
        obj.is_roam_node = is_roam_node # type: ignore
        return obj
    
    def __str__(self):
        return f"{self.__class__.__name__}.{self._name_}"


class MediaType(StrEnum):
    TEXT_PLAIN = 'text/plain'
    TEXT_MARKDOWN = 'text/markdown'
    IMAGE_JPEG = 'image/jpeg'

    def __str__(self):
        return f"{self.__class__.__name__}.{self._name_}"


class RoamVertex(ABC):
    """
    A struct representing a single Vertex that is output by PageDump.js

    ...

    Attributes
    ----------
    uid : Uid
        see ``Uid: TypeAlias`` for description of semantics

    vertex_type : VertexType
        this is abstract -- hardwired into subclasses
        
    media_type : MediaType
        https://en.wikipedia.org/wiki/Media_type
        https://www.iana.org/assignments/media-types/media-types.xhtml
    """

    def __init__(self: Any, uid: Uid, media_type: MediaType): 
        if any(arg is None for arg in (uid, media_type)):
            raise ValueError("missing required arg")
        if not isinstance(media_type, MediaType):
            raise TypeError(f"is not instanceof {MediaType}; media_type: {media_type}")
        
        # PEP 8: "Use one leading underscore only for non-public methods and instance variables."
        self._uid = uid
        self._media_type = media_type

    @property
    def uid(self) -> Uid:
        """is read-only"""
        return self._uid

    @property
    def media_type(self) -> MediaType:
        """is read-only"""
        return self._media_type
    
    @property
    @abstractmethod
    def vertex_type(self) -> VertexType:
        """is read-only"""
        pass

    def __repr__(self):
        clsname: str = type(self).__name__
        uid_string: str = self.uid[-9:] if len(self.uid) > 9 else self.uid
        property_values: dict[str,Any] = get_property_values(self, True)
        logging.debug(f"property_values: {property_values}")
        # filter out the properties that are defined by this class
        property_values = {k:v for k,v in property_values.items() if k not in ['uid', 'vertex_type', 'media_type']}
        return f"{clsname}<{uid_string}>({self.vertex_type}, {self.media_type}, {property_values})"


VertexMap: TypeAlias = OrderedDict[Uid, 'RoamVertex']
"""
The ``VertexMap`` preserves the item order from the PageDump.json file.
"""


class RoamNode(RoamVertex):

    def __init__(self: Any, uid: Uid, media_type: MediaType, children: Optional[list[Uid]] =[], 
                 references: Optional[list[Uid]] =[]): 
        self._children= children
        self._references= references
        super().__init__(uid, media_type)

    @property
    def children(self) -> Optional[list[Uid]]:
        """is read-only"""
        return self._children

    @property
    def references(self) -> Optional[list[Uid]]:
        """is read-only"""
        return self._references


class PageNode(RoamNode):

    def __init__(self: Any, uid: Uid, media_type: MediaType, title: str, children: Optional[list[Uid]] =[], 
                 references: Optional[list[Uid]] =[]): 
        if any(arg is None for arg in (title)):
            raise ValueError("missing required arg")

        self._title = title
        super().__init__(uid, media_type, children, references)

    @property
    def title(self) -> str:
        return self._title
    

    @property
    def vertex_type(self) -> VertexType:
        return VertexType.ROAM_PAGE


class BlockHeadingNode(RoamNode):

    def __init__(self: Any, uid: Uid, media_type: MediaType, heading: str, level: int, 
                 children: Optional[list[Uid]] =[], references: Optional[list[Uid]] =[]): 
        if any(arg is None for arg in (heading, level)):
            raise ValueError("missing required arg")

        self._heading = heading
        self._level = level
        super().__init__(uid, media_type, children, references)

    @property
    def heading(self) -> str:
        return self._heading

    @property
    def level(self) -> int:
        return self._level

    @property
    def vertex_type(self) -> VertexType:
        return VertexType.ROAM_BLOCK_HEADING


class BlockContentNode(RoamNode):

    def __init__(self: Any, uid: Uid, media_type: MediaType, content: str, children: Optional[list[Uid]] =[], 
                 references: Optional[list[Uid]] =[]): 
        self._content = content
        super().__init__(uid, media_type, children, references)

    @property
    def content(self) -> str:
        return self._content
    

    @property
    def vertex_type(self) -> VertexType:
        return VertexType.ROAM_BLOCK_CONTENT


class FileVertex(RoamVertex):

    def __init__(self: Any, uid: Uid, media_type: MediaType, file_name: str, source: Url): 
        if any(arg is None for arg in (file_name, source)):
            raise ValueError("missing required arg")

        self._file_name = file_name
        self._source = source
        super().__init__(uid, media_type)

    @property
    def file_name(self) -> str:
        return self._file_name
    
    @property
    def source(self) -> Url:
        return self._source

    @property
    def vertex_type(self) -> VertexType:
        return VertexType.ROAM_FILE

def all_children(graph: VertexMap) -> list[Uid]:
    logging.debug(f"graph: {graph}")
    if graph is None: 
        return []

    if not isinstance(graph, VertexMap.__origin__): # type: ignore
        raise TypeError()
        
    return list(reduce(_accumulate_children, graph.values(), []))


def _accumulate_children(accumulator: list[Uid], vertex: RoamVertex) -> list[Uid]:
    if not isinstance(vertex, RoamNode):
        return accumulator
    
    node: RoamNode = cast(RoamNode, vertex)
    children: Optional[list[Uid]] = node.children
    if not children:
        return accumulator

    return accumulator + children


ValidationFailure = NamedTuple("ValidationFailure", [('rule', 'ValidationRule'), ('failure_message', str)])
ValidationResult: TypeAlias = Optional[list[ValidationFailure]]
Validation: TypeAlias = Callable[['ValidationRule', VertexMap], ValidationResult]


class ValidationRule(NamedTuple):
    name: str
    description: str
    impl: Validation

    def validate(self, graph: VertexMap) -> ValidationResult: 
        logging.debug(f"rule: {self}")
        if graph is None: 
            return None
    
        if not isinstance(graph, VertexMap.__origin__): # type: ignore
            raise TypeError()
    
        return self.impl(self, graph)


def validate_root_page(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    first_vertex: RoamVertex = list(graph.items())[0][1]
    logging.debug(f"first_node: {first_vertex}")

    if( first_vertex.vertex_type is VertexType.ROAM_PAGE):
        return None
    
    failure_message: str = f"is not {VertexType.ROAM_PAGE}; first vertex: {first_vertex}"
    return [ValidationFailure(ROOT_PAGE_RULE, failure_message)]


ROOT_PAGE_RULE: Final[ValidationRule] = ValidationRule(
    'RootPageRule', 
    'first RoamVertex in the map is a PageNode; the root of the graph', 
    validate_root_page
)


def validate_children_exist(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError


CHILDREN_EXIST_RULE: Final[ValidationRule] = ValidationRule(
    'ChildrenExistRule', 
    'all ``Uid`` values appearing in ``children`` have corresponding entry in VertexMap', 
    validate_children_exist
)


def validate_references_exist(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError


REFERENCES_EXIST_RULE: Final[ValidationRule] = ValidationRule(
    'ReferencesExistRule', 
    'all ``Uid`` values appearing in ``references`` have corresponding entry in VertexMap', 
    validate_references_exist
)




def validate_block_parents_exist(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError

BLOCK_PARENTS_EXIST_RULE: Final[ValidationRule] = ValidationRule(
    'BlockParentsExistRule', 
    'every (BlockHeadingNode | BlockContentNode) ``Uid`` must appear in exactly 1 ``children`` lists', 
    validate_block_parents_exist
)

def validate_children_vertex_types(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError

CHILDREN_VERTEX_TYPES_RULE: Final[ValidationRule] = ValidationRule(
    'ChildrenVertexTypesRule', 
    'no (PageNode | FileVertex) ``Uid`` can appear in any ``children`` lists', 
    validate_children_vertex_types
)

def validate_page_node_children(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError

PAGE_NODE_CHILDREN_RULE: Final[ValidationRule] = ValidationRule(
    'PageNodeChildrenRule', 
    'all ``children`` of ``PageNode`` are (BlockHeadingNode | BlockContentNode)', 
    validate_page_node_children
)

def validate_block_heading_children(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError

BLOCK_HEADING_CHILDREN_RULE: Final[ValidationRule] = ValidationRule(
    'BlockHeadingChildrenRule', 
    'all ``children`` of ``BlockHeadingNode`` are ``BlockContentNode``', 
    validate_block_heading_children
)

def validate_children_attribute_appearance(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError

CHILDREN_ATTRIBUTE_APPEARANCE_RULE: Final[ValidationRule] = ValidationRule(
    'ChildrenAttributeAppearanceRule', 
    '``children`` attribute can only appear on (PageNode | BlockHeadingNode | BlockContentNode)', 
    validate_children_attribute_appearance
)

def validate_references_attribute_appearance(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError

REFERENCES_ATTRIBUTE_APPEARANCE_RULE: Final[ValidationRule] = ValidationRule(
    'ReferencesAttributeAppearanceRule', 
    '``references`` attribute can only appear on (BlockContentNode)', 
    validate_references_attribute_appearance
)

def validate_references_appear_in_content(rule: ValidationRule, graph: VertexMap) -> ValidationResult:
    raise NotImplementedError

REFERENCES_APPEAR_IN_CONTENT_RULE: Final[ValidationRule] = ValidationRule(
    'ReferencesAppearInContentRules', 
    'all ``references`` of BlockContentNode appear in the ``content``, each formatted as a valid ref format type', 
    validate_references_appear_in_content
)

ALL_RULES: Final[list[ValidationRule]] = [
    # simply comment out any rules you wish to disable
    ROOT_PAGE_RULE,
    CHILDREN_EXIST_RULE,
    REFERENCES_EXIST_RULE,
    BLOCK_PARENTS_EXIST_RULE,
    CHILDREN_VERTEX_TYPES_RULE,
    PAGE_NODE_CHILDREN_RULE,
    BLOCK_HEADING_CHILDREN_RULE,
    CHILDREN_ATTRIBUTE_APPEARANCE_RULE,
    REFERENCES_ATTRIBUTE_APPEARANCE_RULE,
    REFERENCES_APPEAR_IN_CONTENT_RULE,
]

def validate(graph: VertexMap) -> ValidationResult: 
    """Checks all of the invariants that should hold for a Roam/PageDump graph

    validations:
    - first RoamVertex in the map is a PageNode; the root of the graph
    - all ``Uid`` values appearing in ``children`` have corresponding entry in VertexMap
    - all ``Uid`` values appearing in ``references`` have corresponding entry in VertexMap
    - every (BlockHeadingNode | BlockContentNode) ``Uid`` must appear in exactly 1 ``children`` lists
    - no (PageNode | FileVertex) ``Uid`` can appear in any ``children`` lists
    - all ``children`` of ``PageNode`` are (BlockHeadingNode | BlockContentNode)
    - all ``children`` of ``BlockHeadingNode`` are ``BlockContentNode``
    - ``children`` attribute can only appear on (PageNode | BlockHeadingNode | BlockContentNode)
    - ``references`` attribute can only appear on (BlockContentNode)
    - all ``references`` of BlockContentNode appear in the ``content``, each formatted as a valid ref format type
    
    Parameters
    ----------
    graph : VertexMap
        the graph to check

    Returns
    -------
    ValidationResult === (None | list[ValidationFailure])
    - None: if there are no validation failures
    - list[ValidationFailure] === list[description of validation failure encountered]
    """
    logging.debug(f"graph: {graph}")
    results: list[ValidationResult] = [rule.validate(graph) for rule in ALL_RULES]
    logging.debug(f"results: {results}")
    results: list[ValidationResult] = list(filter(lambda x: x is not None, results))

    if not results:
        return None
    
    flat_result: list[ValidationFailure] = 
        list(reduce(lambda accum, iter_val: accum + iter_val, results, []))  # type: ignore

    if not flat_result:
        return None
    
    return flat_result

